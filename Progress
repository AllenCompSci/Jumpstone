4/27/2017
/*
Peter Cardenas, Alex Huang, and Adity
Computer Science I
Start: 4..2017
End: ..2017
Jumpstone: Hearthstone with Mario Characters
*/
#include <iostream>
#include <string>
#include <graphics.h>
#include <ctime>
#include <winbgi.cpp>
#include <string>
#include <Windows.h>
#include <cmath>
using namespace std;
void gr_Start(int &GrDriver, int&GrMode, int&ErrorCode);
void stats(int ID);
void setRarity(int ID);
void setName(int ID);
void setAttack(int ID);
void setDefense(int ID);
void setManaCost(int ID);
void ability(int ID);
void playCard(int ID);
void drawCard();
void render(int ID);
void attacking(int attackerID, int attackeeID);
struct Player {
	int Deck[30];
	int Hand[7];
	int decideF;
	bool isF;
	void isFirst() {
		decideF = rand() % 2 + 1;
		if (decideF == 1) {
			bool isF = true;
		}
		else {
			bool isF = false;
		}
	}
	void createDeck() {
		bool isDup[66];
		for (int i = 0; i < 66; i++) {
			isDup[i] = false;
		}
		Deck[0] = 3;
		Deck[1] = 5;
		Deck[2] = 8;
		Deck[3] = 11;
		Deck[4] = 16;
		Deck[5] = 29;
		Deck[6] = 35;
		Deck[7] = 43;
		Deck[8] = 54;
		Deck[9] = 59;
		Deck[10] = 20;
		Deck[11] = 4;
		Deck[12] = 42;
		Deck[13] = 44;
		Deck[14] = 56;
		for (int i = 15; i < 30; i++) {
			Deck[i] = rand() % 66 + 1;
			for (int j = 0; j < i; j++) {
				if (isDup[Deck[i]] == true) {
					j = i;
					i--;
				}
				else if (Deck[i] == Deck[j]) {
					isDup[Deck[i]] = true;
				}
			}
		}
	}
	void isDrawn(int ID) {
		Deck[ID] = -1;
	}
}Opponent,User;
void main() {
	srand((unsigned int)time(NULL));
	system("pause");
	return;
}
void stats(int ID) {
	setAttack(ID);
	setDefense(ID);
	setManaCost(ID);
	setName(ID);
}
void setRarity(int ID) {

}
void setName(int ID) {

}
void setAttack(int ID) {

}
void setDefense(int ID) {

}
void setManaCost(int ID) {

}
void ability(int ID) {

}
void playCard(int ID){
	stats(ID);
	render(ID);
}
void drawCard() {
	
}
void gameStart() {
	Opponent.createDeck();
	User.createDeck();
}
void matchStart() {
	mulligan();
}
void decideFOS() {
	User.isFirst();
	if (User.isF) {
		Opponent.isF = false;
	}
	else {
		Opponent.isF = false;
	}
}
void mulligan() {
	//three cards each player, second player gets 2 coins
	decideFOS();
	int choice;
	bool clickedRegion1;
	bool clickedRegion2;
	bool clickedRegion3;
	bool mDone;
	if (User.isF) {
		for (int i = 0; i < 3; i++) {
			choice = rand() % 30;
			User.Hand[i] = User.Deck[choice];
			User.isDrawn(choice);
			choice = rand() % 30;
			Opponent.Hand[i] = Opponent.Deck[choice];
			Opponent.isDrawn(choice);
		}
		Opponent.Hand[3], Opponent.Hand[4] = 67;
	}
	else if(Opponent.isF) {
		for (int i = 0; i < 3; i++) {
			choice = rand() % 30;
			User.Hand[i] = User.Deck[choice];
			User.isDrawn(choice);
			choice = rand() % 30;
			Opponent.Hand[i] = Opponent.Deck[choice];
			Opponent.isDrawn(choice);
		}
		User.Hand[3], User.Hand[4] = 67;
	}
	if (mDone) {
		if (clickedRegion1) {
			if (clickedRegion2) {
				if (clickedRegion3) {

				}
				else {

				}
			}
			else if (clickedRegion3) {

			}
		}
		else if (clickedRegion2) {
			if (clickedRegion3) {

			}
			else {

			}
		}
		else if (clickedRegion3) {

		}
	}
}
void turn() {
	drawCard();
}
void render(int ID) {

}
void attacking(int attackerID, int attackeeID){
	/*
	hero attack value is first set to zero
	*/
	
}
void gr_Start(int &GrDriver, int&GrMode, int&ErrorCode) {
	//set the graphics driver
	GrDriver = VGA; //800x600 by monitor
	GrMode = VGAMAX;//set graphics mode
	initgraph(&GrDriver, &GrMode, "");//start graphics
									  //check for problems
	ErrorCode = graphresult();
	if (ErrorCode != grOk)
	{
		cout << "Error:" << ErrorCode;
	}
}
