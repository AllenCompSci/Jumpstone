5/1/2017
/*
Peter Cardenas, Alex Huang, and Adity
Computer Science I
Start: 4..2017
End: ..2017
Jumpstone: Hearthstone with Mario Characters
*/
#include <iostream>
#include <string>
#include <graphics.h>
#include <ctime>
#include <winbgi.cpp>
#include <string>
#include <Windows.h>
#include <cmath>
using namespace std;
void gr_Start(int &GrDriver, int&GrMode, int&ErrorCode);
void stats(int ID);
void setRarity(int ID);
void setName(int ID);
void setAttack(int ID);
void setDefense(int ID);
void setManaCost(int ID);
void ability(int ID);
void playCard(int ID);
void drawCard();
void render(int ID);
void attacking(int attackerID, int attackeeID);
struct Board {

}UserB, OpponentB;
struct Player {
	int Deck[30];
	int Hand[7];
	int decideF;
	bool isF;
	void isFirst() {
		decideF = rand() % 2 + 1;
		if (decideF == 1) {
			bool isF = true;
		}
		else {
			bool isF = false;
		}
	}
	void createDeck() {
		bool isDup[66];
		for (int i = 0; i < 66; i++) {
			isDup[i] = false;
		}
		Deck[0] = 3;
		Deck[1] = 5;
		Deck[2] = 8;
		Deck[3] = 11;
		Deck[4] = 16;
		Deck[5] = 29;
		Deck[6] = 35;
		Deck[7] = 43;
		Deck[8] = 54;
		Deck[9] = 59;
		Deck[10] = 20;
		Deck[11] = 4;
		Deck[12] = 42;
		Deck[13] = 44;
		Deck[14] = 56;
		for (int i = 15; i < 30; i++) {
			Deck[i] = rand() % 66 + 1;
			for (int j = 0; j < i; j++) {
				if (isDup[Deck[i]] == true) {
					j = i;
					i--;
				}
				else if (Deck[i] == Deck[j]) {
					isDup[Deck[i]] = true;
				}
			}
		}
	}
	void resetHand(int hand[]) {
		int handSize = sizeof(Hand) / sizeof(Hand[0]);
		for (int i = 0; i < handSize; i++) {
			if (hand[i] == -1) {
				for (int j = i; j < handSize; j++) {
					if (j == handSize - 1) {}
					else {
						hand[j] = hand[j + 1];
					}
				}
			}
		}
	}
	int cardsInHand(int Hand[]) {
		int handSize = sizeof(Hand) / sizeof(Hand[0]);
		int count = 0;
		for (int i = 0; i < handSize; i ++) {
			if (Hand[i] > 0) {
				count++;
			}
		}
		return count;
	}
	void isDrawn(int ID) {
		Deck[ID] = -1;
	}
}Opponent,User;
void main() {
	srand((unsigned int)time(NULL));
	system("pause");
	return;
}
void stats(int ID) {
	setAttack(ID);
	setDefense(ID);
	setManaCost(ID);
	setName(ID);
}
void setRarity(int ID) {

}
void setName(int ID) {

}
void setAttack(int ID) {

}
void setDefense(int ID) {

}
void setManaCost(int ID) {

}
void ability(int ID) {
	if (ID == 1 || ID == 3 || ID == 5 || ID == 10 || ID == 68 || ID == 69 || ID == 70 || ID == 71 || ID == 72 || ID == 76 || ID == 81) {

	}

}
void playCard(int ID){
	stats(ID);
	render(ID);
}
void drawCard() {
	
}
void gameStart() {
	Opponent.createDeck();
	User.createDeck();
}
void matchStart() {
	mulligan();
}
void decideFOS() {
	User.isFirst();
	if (User.isF) {
		Opponent.isF = false;
	}
	else {
		Opponent.isF = false;
	}
}
void mulligan() {
	//three cards each player, second player gets 2 coins
	decideFOS();
	int choice;
	int deckSize = sizeof(User.Deck) / sizeof(User.Deck[0]);
	bool clickedRegion1;
	bool clickedRegion2;
	bool clickedRegion3;
	bool mDone;
	if (User.isF) {
		for (int i = 0; i < 3; i++) {
			choice = rand() % deckSize;
			User.Hand[i] = User.Deck[choice];
			User.isDrawn(choice);
			choice = rand() % deckSize;
			Opponent.Hand[i] = Opponent.Deck[choice];
			Opponent.isDrawn(choice);
		}
		Opponent.Hand[3], Opponent.Hand[4] = 67;
	}
	else if(Opponent.isF) {
		for (int i = 0; i < 3; i++) {
			choice = rand() % deckSize;
			User.Hand[i] = User.Deck[choice];
			User.isDrawn(choice);
			choice = rand() % deckSize;
			Opponent.Hand[i] = Opponent.Deck[choice];
			Opponent.isDrawn(choice);
		}
		User.Hand[3], User.Hand[4] = 67;
	}
	if (mDone) {
		if (clickedRegion1) {
			while(User.Hand[0] != -1) {
				int i = 0;
				if (User.Deck[i] = -1) {
					User.Deck[i] = User.Hand[0];
					User.Hand[0] = -1;
				}
				i++;
			}
			if (clickedRegion2) {
				while (User.Hand[1] != -1) {
					int i = 0;
					if (User.Deck[i] = -1) {
						User.Deck[i] = User.Hand[1];
						User.Hand[1] = -1;
					}
					i++;
				}
				if (clickedRegion3) {
					while (User.Hand[2] != -1) {
						int i = 0;
						if (User.Deck[i] = -1) {
							User.Deck[i] = User.Hand[2];
							User.Hand[2] = -1;
						}
						i++;
					}
				}
			}
			else if (clickedRegion3) {
				while (User.Hand[2] != -1) {
					int i = 0;
					if (User.Deck[i] = -1) {
						User.Deck[i] = User.Hand[2];
						User.Hand[2] = -1;
					}
					i++;
				}
			}
		}
		else if (clickedRegion2) {
			while (User.Hand[1] != -1) {
				int i = 0;
				if (User.Deck[i] = -1) {
					User.Deck[i] = User.Hand[1];
					User.Hand[1] = -1;
				}
				i++;
			}
			if (clickedRegion3) {
				while (User.Hand[2] != -1) {
					int i = 0;
					if (User.Deck[i] = -1) {
						User.Deck[i] = User.Hand[2];
						User.Hand[2] = -1;
					}
					i++;
				}
			}
		}
		else if (clickedRegion3) {
			while (User.Hand[2] != -1) {
				int i = 0;
				if (User.Deck[i] = -1) {
					User.Deck[i] = User.Hand[2];
					User.Hand[2] = -1;
				}
				i++;
			}
		}
		for (int i = 0; i < 3; i++) {
			if (User.Hand[i] == -1) {
				choice = rand() % deckSize;
				User.Hand[i] = User.Deck[choice];
				User.isDrawn(choice);
			}
		}
	}
}
void turn() {
	drawCard();
}
void render(int ID) {

}
void attacking(int attackerID, int attackeeID){
	/*
	hero attack value is first set to zero
	*/
	
}
void gr_Start(int &GrDriver, int&GrMode, int&ErrorCode) {
	//set the graphics driver
	GrDriver = VGA; //800x600 by monitor
	GrMode = VGAMAX;//set graphics mode
	initgraph(&GrDriver, &GrMode, "");//start graphics
									  //check for problems
	ErrorCode = graphresult();
	if (ErrorCode != grOk)
	{
		cout << "Error:" << ErrorCode;
	}
}
